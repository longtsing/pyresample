重采样
==========

在一般意义上，重采样是从我们已有的数据创建新数据点的过程。在 Pyresample 中，当我们使用一个 :doc:`几何形状 <geometries>` 的数据来创建另一个几何形状中的数据点时，我们使用术语"重采样"。考虑到可用的几何形状，我们通常在几个常见用例中使用重采样：

* 条带到区域：或者换句话说，将非网格化数据重采样到网格。这有很多原因很有用。大多数区域易于可视化，并提供某种程度上可识别的地球视图。条带并非总是如此。这种重采样还具有区域的所有其他好处，例如更容易描述地理定位以及更容易与其他数据进行比较。这种类型的重采样还允许获取条带的子集或将空间像素分辨率更改为更适合您用例的内容。
* 区域/条带到条带：当组合或比较来自多个来源的数据并且它们都恰好是非网格化条带时，可以使用重采样将它们置于相同的坐标系统上。
* 区域到区域：与将条带重采样到区域类似，我们可能希望获取输入数据的子集或更改分辨率以适合我们的需求。还有机会更改投影或匹配另一个数据集的区域以便更容易比较。

在所有这些情况下，我们需要某种方法来确定在给定一个或多个输入像素的情况下为每个输出像素设置什么值。为此，有许多算法可供选择。Pyresample 中实现的算法如下所述。

有关如何使用 Pyresample 进行重采样的更多信息，请参阅一些 :doc:`/howtos/index`，例如针对条带数据的 :doc:`/howtos/swath` 或针对区域的 :doc:`/howtos/grid`。

算法
----------

在重采样时，我们有很多选项可以将输入像素映射到输出像素。根据我们选择的算法，我们可能会得到比其他算法更好看的结果，但代价是更多的处理时间或更大的内存需求。下面是 Pyresample 中实现的一些算法的基本描述，但有关更详细的描述，请参阅 :doc:`API 文档 </api/pyresample>`，其中记录了低级重采样器类和函数。

请注意，除非另有说明，否则 Pyresample 中实现的算法将所有像素视为位于其中心的单独点。这意味着它们可能通常忽略真实世界足迹的形状以及这些足迹可能的重叠。

.. warning::

   Pyresample 的重采样接口目前正在经历变化，作为 2.0 版本重新设计的一部分。因此，下面描述的现有算法可能只能从特定接口获得，并且可能与其他算法的接口一致或不一致。在撰写本文时，一些算法可能只支持使用 Pyresample 的姊妹项目"Satpy"所需的数据类型。例如，一些可能期望带有 dask 数组的 Xarray ``DataArray`` 类，如果给定常规 numpy 数组，将以丑陋的方式失败。

最近邻
^^^^^^^^^^^^^^^^

最近邻是将输入像素映射到输出像素的最简单方法之一。它将每个输出像素设置为地理位置上最接近输出像素位置的输入像素的值。在 Pyresample 中，这是通过 `pykdtree 包 <https://github.com/storpipfugl/pykdtree>`_ 使用 `k-d 树 <https://en.wikipedia.org/wiki/K-d_tree>`_ 实现的。这个结构是使用输入地理定位创建的，允许快速查询最近输入像素的索引。使用这些索引，我们可以使用基本的 numpy 索引操作创建目标几何形状大小的输出数组。这通常是一个非常快的操作。

输出数组中没有相邻输入像素的任何像素将被分配某个填充值，通常是特殊的浮点 NaN。算法通过"影响半径"决定查找的距离。无论影响半径如何，如果半径内有一个像素，结果将始终是最近的相邻像素，否则将使用填充值。

这个算法及其简单性的一个好处是它适用于任何一对输入和输出几何形状（条带、区域等），无论像素是否保留拓扑。这对所有算法来说不一定是真的。这是 pyresample 中实现的最古老的算法，已经在不同的接口中进行了调整，以支持 numpy、dask 和 xarray DataArrays。

缓存
*******

由于此算法使用 k-d 树以及通过查询它生成的索引的方式，索引可以很容易地被缓存。由于 kd 树仅使用输入地理定位进行创建和输出地理定位进行查询，因此我们可以为共享相同地理定位的任何输入数据重用生成的索引。这可以通过不必重新生成或重新查询 k-d 树来大大提高性能。如果我们的条带或基于区域的输入在执行之间相同，我们还可以将这些索引写入磁盘，并在下一次执行中使用它们，而无需生成或查询 k-d 树。

梯度搜索
^^^^^^^^^^^^^^^

梯度搜索算法基于 Alexander Trishchenko 的工作（参见 :doi:`10.1109/TGRS.2008.916633`）。该算法受益于其假设数组表示保留了观测数据的拓扑结构。通过仅查看附近的像素，该算法可以有效地计算最近邻或执行双线性插值。

对于存在的接口（见下面的警告）以及满足该算法限制的数据（保留拓扑等），对于最近邻，此算法应该比 k-d 树方法（见上文）以及 Pyresample 中实现的其他双线性算法（见下文）更快且更节省内存。该算法目前不支持缓存，但由于其速度也不需要。

.. warning::

   此重采样算法仍被视为实验性的。在撰写本文时，它仅支持区域到区域的重采样，并且需要由 dask 数组支持的 xarray DataArray 对象。

双线性
^^^^^^^^

Pyresample 还提供了一个独立的双线性算法，该算法在梯度搜索之前就存在。它基于与上面描述的最近邻算法相同的 k-d 树。由于它使用 k-d 树，因此能够处理不保留数据地理拓扑的数组。它目前仅限于以 dask 数组作为输入的 xarray DataArray。当前的实现目前需要为每个输出像素获取多个附近的邻居，然后在四个最近的周围像素之间进行双线性插值。这通常使用大量 CPU 和内存。对于保留拓扑的数据，建议使用梯度搜索算法。

桶
^^^^^^

桶重采样算法实际上是遵循类似结构的多个算法。桶重采样用于计算输入数据落入输出像素（"桶"）内的各种类型的统计数据。这些统计数据包括总和、最小值、最大值、计数、平均值以及整数类别数据的每个类别的分数。由于几何形状之间可能存在的差异（例如投影、像素分辨率等），输出像素可能与零个或多个输入像素重叠。桶重采样不是只获取最近的输入像素（最近邻），而是允许我们获取最大输入值、或最小值、或平均值、或任何其他已实现的计算。这允许对最终输出进行更多控制，根据正在处理的数据类型，这可能更有用或更准确。

当前的实现仅限于 xarray DataArrays 和 dask 数组。

椭圆加权平均
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Pyresample 可以使用椭圆加权平均算法或简称 EWA 将条带数据重采样到均匀网格。此算法的行为与基于 KDTree 的重采样算法不同。基于 KDTree 的算法通过搜索所有"附近"的输入像素并应用某种插值（最近邻、高斯等）来处理每个输出网格像素。EWA 算法处理每个输入像素，将其映射到一个或多个输出像素。一旦分析了每个输入像素，就会对中间结果进行平均以产生最终的网格化结果。

与通用 KDTree 算法相比，EWA 算法对输入数据的结构也有限制。EWA 假设数组中的数据是按地理组织的；数组中相邻的数据在地理上是相邻的数据。该算法使用它根据条带像素的大小和位置配置参数。它还假设数据是基于扫描的，由轨道卫星逐扫描记录，用户必须使用 ``rows_per_scan`` 选项提供扫描大小。

EWA 算法由两个步骤组成：ll2cr 和 fornav。该算法最初是 NASA 国家雪冰数据中心（NSIDC）创建的 MODIS Swath to Grid Toolbox（ms2gt）的一部分。其默认参数最适合 MODIS L1B 数据，但已被证明可以使用正确的参数从 VIIRS 和 AVHRR 数据生成高质量的图像。

有多个高级接口可用于此算法，以支持 numpy 数组或由 dask 数组支持的 xarray DataArrays。
